Docker + Ubuntu + Nginx Experiment – Command List

1. Check Docker Version
docker --version

2. Pull Ubuntu Image
docker pull ubuntu:latest

3. Run Ubuntu Container
docker run -it -p 3000:80 --name myubuntu ubuntu:latest

4. Inside Container: Update Packages
apt update

5. Install Nginx
apt install nginx -y

6. Start Nginx
nginx

7. Navigate to Web Directory
cd /var/www/html

8. Rename Default Page
mv index.nginx-debian.html index.html

9. Edit Homepage Content
echo '<h1>Hello from Docker Nginx!</h1>' > index.html

10. View in Browser
http://localhost:3000








Docker Image Creation Experiment (Two Methods)
-------------------------------------------------

PART A: Create Image Using docker commit
---------------------------------------

1. Pull Ubuntu image
docker pull ubuntu:latest

2. Run Ubuntu container
docker run -it --name mycontainer ubuntu:latest

3. Inside container: create a file using cat
cat > myfile.txt
Hello from my custom image!
<Ctrl + D>

4. Exit the container
exit

5. Create an image from the container
docker commit mycontainer myimage:v1

6. Verify image
docker images

7. Run a new container from committed image
docker run -it myimage:v1


PART B: Create Image Using Dockerfile
--------------------------------------

1. Create a new folder
mkdir mydockerfileimages
cd mydockerfileimages

2. Create a message file
notepad message.txt
(Write: This image was created using Dockerfile.)

3. Create Dockerfile (Notepad may save as .txt)
notepad Dockerfile

4. If Notepad saved it as Dockerfile.txt, rename it:
rename-item Dockerfile.txt Dockerfile

5. Verify files
ls
(Dockerfile and message.txt must be visible)

6. Build image using Dockerfile
docker build -t mydockerfileimage:v1 .

7. Verify image
docker images

8. Run container from Dockerfile image
docker run -it mydockerfileimage:v1

9. Check the copied file inside container
cat /message.txt























Docker Compose Experiment – Running Multiple Containers
-------------------------------------------------------------

AIM:
To run two servers (Nginx and TomEE) simultaneously using Docker Compose.

-------------------------------------------------------------
PART 1: Running Two Servers Manually
-------------------------------------------------------------

1. Run Nginx on port 8010:
docker run -d -p 8010:80 nginx

2. Run TomEE on port 8020:
docker run -d -p 8020:8080 tomee

3. Open localhost to view servers:
http://localhost:8010   (Nginx)
http://localhost:8020   (TomEE)


-------------------------------------------------------------
PART 2: Running the Same Two Servers Using Docker Compose
-------------------------------------------------------------

Step 1: Create project folder:
mkdir comp-1-server
cd comp-1-server

Step 2: Create docker-compose.yml:
notepad docker-compose.yml

Paste the following content:

-------------------------------------------------------------
docker-compose.yml (CODE)
-------------------------------------------------------------
services:
  web:
    image: nginx
    ports:
      - "8060:80"

  db:
    image: tomee
    ports:
      - "8050:8080"
-------------------------------------------------------------

Step 3: If saved incorrectly, rename (optional):
ren Dockerfile docker-compose.yml

Step 4: Start both containers using Docker Compose:
docker-compose up -d

Step 5: Verify containers:
docker ps

Step 6: Open the servers in browser:
http://localhost:8060   (Nginx from Compose)
http://localhost:8050   (TomEE from Compose)

-------------------------------------------------------------

END OF EXPERIMENT







wordpress:
docker-compose.yml

services:
  wordpress:
    image: wordpress:latest
    ports: 
    - "9080:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
    - db
  db:
    image: mysql:5.7
    ports:
    - "9088:81"
    environment:
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
      MYSQL_DATABASE: wordpress
      MYSQL_ROOT_PASSWORD: rootpassword













Flask + MySQL Docker Compose Experiment
=========================================

AIM:
To create a Flask application and MySQL database using Docker Compose and run them together.

---------------------------------------------------------
Step 1: Create project folder
---------------------------------------------------------
mkdir custom_flask
cd custom_flask

---------------------------------------------------------
Step 2: Create app.py
---------------------------------------------------------
# app.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def home():
    return "Hello from 24BDSA0503 - NEKSHASRINIVAS"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

---------------------------------------------------------
Step 3: Create Dockerfile
---------------------------------------------------------
# Dockerfile
FROM python:3.10-slim

WORKDIR /app
COPY app.py /app/
RUN pip install flask
CMD ["python", "app.py"]

---------------------------------------------------------
Step 4: Create docker-compose.yml
---------------------------------------------------------
# docker-compose.yml
services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: mydb
    ports:
      - "3307:3306"   # Changed because 3306 is busy on Windows

---------------------------------------------------------
Step 5: Build and Run Containers
---------------------------------------------------------
docker compose up --build

---------------------------------------------------------
Step 6: Test the Application
---------------------------------------------------------
Open in browser:
http://localhost:5000

MySQL connection (optional):
Host: localhost
Port: 3307
User: root
Password: root

---------------------------------------------------------
END OF EXPERIMENT















Multi-Module Maven Project – Detailed Explanation
=================================================

1. What is a Multi-Module Maven Project?
----------------------------------------
A multi-module Maven project allows you to manage multiple related modules under
one parent project. The parent controls dependencies, versions, plugins, and build
order. All modules build together using: mvn clean install.

Structure:
MyParentProject (parent)
 ├── pom.xml  
 ├── module1  
 │     └── pom.xml  
 └── module2  
       └── pom.xml  

------------------------------------------------------------

2. Creating the Parent Project
------------------------------

Step 1: Create folder
mkdir MyParentProject
cd MyParentProject

Step 2: Create parent pom.xml with packaging=pom and module list:

<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>MyParentProject</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>pom</packaging>

  <modules>
    <module>module1</module>
    <module>module2</module>
  </modules>
</project>

------------------------------------------------------------

3. Creating Module 1
--------------------

Command:
mvn archetype:generate -DgroupId=com.example -DartifactId=module1 -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

module1/pom.xml:

<project>
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>com.example</groupId>
    <artifactId>MyParentProject</artifactId>
    <version>1.0-SNAPSHOT</version>
  </parent>

  <artifactId>module1</artifactId>
</project>

------------------------------------------------------------

4. Creating Module 2
--------------------

Command:
mvn archetype:generate -DgroupId=com.example -DartifactId=module2 -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

module2/pom.xml similar to module1 except artifactId=module2.

------------------------------------------------------------

5. Final Project Structure
--------------------------

MyParentProject/
 ├── pom.xml (parent)
 ├── module1/
 │     └── pom.xml
 └── module2/
       └── pom.xml

------------------------------------------------------------

6. Build Entire Multi-Module Project
------------------------------------

Inside parent folder:
mvn clean install

This builds:
- Parent POM
- Module 1
- Module 2

------------------------------------------------------------

7. Viva Questions
-----------------

Q: Why multi-modules?
A: To manage multiple related modules under one parent.

Q: Why packaging pom?
A: Parent is only a container for modules.

Q: How to build all modules?
A: mvn clean install

Q: How do modules inherit dependencies?
A: Through the parent POM using <parent> tag.

------------------------------------------------------------


















<role rolename="manager-gui"/>
<role rolename="manager-script"/>
<role rolename="manager-jmx"/>
<role rolename="manager-status"/>
<user username="vishnu" password="vishnu" roles="manager-gui,manager-script,manager-jmx,manager-status"/>
















WORDPRESS + MYSQL USING DOCKER COMPOSE
==========================================

AIM:
To deploy WordPress with a MySQL database using Docker Compose and complete the WordPress installation.

---------------------------------------------------------
STEP 1: Create a folder and docker-compose.yml file
---------------------------------------------------------
mkdir mysql
cd mysql
notepad docker-compose.yml

If saved as docker-compose.txt, rename it:
ren docker-compose.txt docker-compose.yml

---------------------------------------------------------
STEP 2: docker-compose.yml CONTENT
---------------------------------------------------------
services:

  wordpress:
    image: wordpress:latest
    ports:
      - "9080:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db

  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
    ports:
      - "3307:3306"

---------------------------------------------------------
STEP 3: Run Docker Compose
---------------------------------------------------------
docker-compose up -d

This starts:
- WordPress container
- MySQL database container

---------------------------------------------------------
STEP 4: Open WordPress Installation Page
---------------------------------------------------------
Open browser and go to:
http://localhost:9080

Select your preferred language and click Continue.

---------------------------------------------------------
STEP 5: Fill the WordPress Welcome Page
---------------------------------------------------------
Example values:

Site Title: Hey
Username: Neksha Srinivas
Password: Sri@121318
Email: edigirlaneksha@gmail.com

Click "Install WordPress".

---------------------------------------------------------
STEP 6: Installation Success Message
---------------------------------------------------------
You will see:
"WordPress has been installed successfully!"

Click the Log In button.

---------------------------------------------------------
STEP 7: Log in to WordPress Dashboard
---------------------------------------------------------

Login URL:
http://localhost:9080/wp-admin

Use the credentials you created:

USERNAME:
Neksha Srinivas

PASSWORD:
Sri@121318

---------------------------------------------------------
STEP 8: After Login
---------------------------------------------------------
You will see the WordPress Admin Dashboard:
- Posts
- Media
- Pages
- Appearance
- Plugins
- Settings

WordPress is now fully installed and running using Docker Compose.

---------------------------------------------------------
END OF EXPERIMENT















minikube start
kubectl create deployment mynginx --image=nginx
kubectl expose deployment mynginx --type=NodePort --port=80 --target-port=80
kubectl scale deployment mynginx --replicas=4
kubectl get service myngnix
kubectl port-forward svc/mynginx 8081:80















Minikube & Kubernetes Commands Used
===================================

1. Start Minikube (initial attempt)
-----------------------------------
minikube start


4. Try Docker driver (fails due to mismatch)
--------------------------------------------
minikube start --driver=docker

5. Delete existing cluster
--------------------------
minikube delete

6. Start Minikube with Docker driver (successful)
-------------------------------------------------
minikube start --driver=docker

7. Check pods in all namespaces
-------------------------------
minikube kubectl -- get pods -A

8. Create a deployment using nginx image
----------------------------------------
kubectl create deployment mynginx --image=nginx

9. Expose the deployment as a NodePort service
----------------------------------------------
kubectl expose deployment mynginx --type=NodePort --port=80 --target-port=80

10. Scale deployment replicas
-----------------------------
kubectl scale deployment mynginx --replicas=4

11. Port forward service to localhost
-------------------------------------
kubectl port-forward svc/mynginx 9090:80

------------------------------------------------------nagios
docker pull jasonrivers/nagios:latest
docker run --name nagiosdemo -p 8888:80 jasonrivers/nagios:latest
nagiosadmin
nagios















pipeline {
    agent any

    stages {

        stage('Clone Repository') {
            steps {
                echo "Cloning the project..."
                git branch: 'main', url: 'YOUR_REPO_URL_HERE'
            }
        }

        stage('Detect Project Type') {
            steps {
                script {
                    if (fileExists('package.json')) {
                        env.PROJECT_TYPE = 'node'
                    } else if (fileExists('pom.xml')) {
                        env.PROJECT_TYPE = 'java-maven'
                    } else if (fileExists('requirements.txt')) {
                        env.PROJECT_TYPE = 'python'
                    } else {
                        env.PROJECT_TYPE = 'static'
                    }

                    echo "Detected project type: ${env.PROJECT_TYPE}"
                }
            }
        }

        stage('Build') {
            steps {
                script {
                    if (env.PROJECT_TYPE == 'node') {
                        sh 'npm install'
                        sh 'npm run build || echo "No build script"'
                    } else if (env.PROJECT_TYPE == 'java-maven') {
                        sh 'mvn clean package'
                    } else if (env.PROJECT_TYPE == 'python') {
                        sh 'pip install -r requirements.txt'
                    } else {
                        echo "Static project — no build needed."
                    }
                }
            }
        }

        stage('Test') {
            steps {
                script {
                    if (env.PROJECT_TYPE == 'node') {
                        sh 'npm test || echo "No tests found"'
                    } else if (env.PROJECT_TYPE == 'java-maven') {
                        sh 'mvn test'
                    } else if (env.PROJECT_TYPE == 'python') {
                        sh 'pytest || echo "No tests found"'
                    } else {
                        echo "Static project — no tests."
                    }
                }
            }
        }

        stage('Deploy Simulation') {
            steps {
                echo "Deploy step executed successfully."
            }
        }
    }

    post {
        success { echo "Pipeline completed successfully!" }
        failure { echo "Pipeline failed!" }
    }
}





























